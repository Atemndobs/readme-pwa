name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Debug Environment
        run: |
          echo "Node version:"
          node --version
          echo "NPM version:"
          npm --version
          echo "Current directory:"
          pwd
          echo "Directory contents:"
          ls -la

      - name: Install dependencies
        run: |
          echo "Installing dependencies..."
          npm ci
          echo "Installed dependencies successfully"
          echo "node_modules contents:"
          ls -la node_modules | head -n 5

      - name: Run linting
        run: |
          echo "Running linting..."
          npm run lint
        continue-on-error: true

      - name: Run type checking
        run: |
          echo "Running type checking..."
          npm run typecheck
        continue-on-error: false

  deploy:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    env:
      APP_NAME: readme-pwa
      APP_DIR: /home/atem/docker/readme-pwa
      PROD_URL: https://tts.cloud.atemkeng.de
    
    steps:
      - name: Deploy to production server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USERNAME }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script: |
            #!/bin/bash
            set -e
            
            # Configuration
            APP_NAME="readme-pwa"
            APP_DIR="/home/atem/docker/readme-pwa"
            PROD_URL="https://tts.cloud.atemkeng.de"
            
            echo "Starting production deployment process..."
            
            # Pull latest changes from production
            cd "$APP_DIR"
            echo "Pulling latest changes..."
            git fetch origin main
            if ! git pull origin main; then
                echo "Pull failed, resetting branch..."
                git reset --hard origin/main
                git pull origin main
            fi
            
            # Get current version and calculate new version
            CURRENT_VERSION=$(grep -oP "image: ${APP_NAME}:\K[0-9]+\.[0-9]+\.[0-9]+" docker-compose.yml || echo "1.0.0")
            MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
            MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
            PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
            NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
            echo "Current version: $CURRENT_VERSION"
            echo "New version: $NEW_VERSION"
            
            # Get the latest git log message and today's date for changelog
            LATEST_CHANGES=$(git log -1 --pretty=%B | sed 's/["\]/\\&/g' | tr '\n' ' ')
            TODAY_DATE=$(date +%Y-%m-%d)
            
            # Ensure directories exist
            mkdir -p src/utils
            
            # Update version file and changelog
            echo "Updating version files..."
            echo "export const APP_VERSION = '${NEW_VERSION}';" > src/utils/version.ts
            
            # Create new changelog entry
            cat << 'EOLMARK' > src/utils/changelog.ts
            import { APP_VERSION } from './version'
            export type VersionInfo = {
              version: string
              date: string
              changes: string[]
            }
            export const CHANGELOG: Record<string, VersionInfo> = {
              "\${APP_VERSION}": {
                version: "\${APP_VERSION}",
                date: "\${TODAY_DATE}",
                changes: [
                  "\$(echo "\${LATEST_CHANGES}" | sed 's/"/\\"/g')"
                ]
              }
            }
            EOLMARK
            
            # Build production image locally
            echo "Building production Docker image..."
            docker buildx build \
              --platform linux/amd64 \
              --target runner \
              --build-arg NEXT_PUBLIC_API_URL="$PROD_URL" \
              -t "${APP_NAME}:${NEW_VERSION}" \
              --load \
              .
            
            # Update docker-compose.yml with new version
            echo "Updating docker-compose.yml..."
            sed -i "s/${APP_NAME}:${CURRENT_VERSION}/${APP_NAME}:${NEW_VERSION}/" docker-compose.yml
            
            # Stop and remove existing container
            echo "Cleaning up existing containers..."
            docker stop "$APP_NAME" || true
            docker rm "$APP_NAME" || true
            
            # Deploy with docker-compose
            echo "Deploying new version..."
            docker-compose up -d --force-recreate
            
            # Check container health
            echo "Checking container health..."
            for i in {1..6}; do
                if curl -s http://localhost:3007/api/health > /dev/null; then
                    echo "Application is healthy!"
                    exit 0
                fi
                echo "Waiting for application to become healthy... ($i/6)"
                sleep 10
            done
            
            echo "Warning: Application health check failed!"
            exit 1
